---
title: "Plotting value distributions on taxonomies"
output:
  rmarkdown::html_vignette:
    toc: true
    css: custom.css
    includes:
      before_body: doc_prefix.html
      after_body: doc_suffix.html
vignette: >
  %\VignetteIndexEntry{Plotting value distributions on taxonomies}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(ape)
library(metacoder)
library(taxa)
library(knitr)
library(ggplot2)
opts_chunk$set(dev='svg', warning = FALSE, message = FALSE, fig.show='hold')
```

## Introduction

Visualizing statistics associated with taxa can be difficult due to the hierarchical nature of the information.
Traditional graph types used to visualize the relationship between categories (e.g. taxa) and quantities (e.g. abundance) such as bar charts, pie charts, and box plots, are fundamentally two-dimensional. 
This means the it is usually necessary to only view a 'slice' of the data, such as the abundance of taxa of a particular rank, rather than all ranks. 
To demonstrate this idea, lets display the same data using various graphing techniques and compare their effectiveness.
For this example we will be using a sample of 500 sequences from the UNITE fungal ITS database.
First, we will use a bar chart to display abundance of taxa at each rank:

```{r, echo=FALSE}
file_path <- system.file("extdata", "unite_general_release.fasta", package = "metacoder")
sequences <- ape::read.FASTA(file_path)
original_data <- extract_taxonomy(names(sequences),
                         regex = "^(.*)\\|(.*)\\|(.*)\\|.*\\|(.*)$",
                         key = c(name = "item_info", seq_id = "item_info",
                                 other_id = "item_info", "class_name"),
                         database = "none")
```



```{r, echo=FALSE, fig.width = 6.5, fig.height = 6.5}
data <- taxon_data(original_data)
data$name <- factor(data$name, levels = unique(data$name[order(data$item_count, decreasing = TRUE)]), ordered = TRUE)
data$rank <- factor(data$rank, levels = unique(data$rank),
                    labels = c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), 
                    ordered = TRUE)
ggplot(data[!data$rank  %in% c("Kingdom", "Species", "Genus"), ]) + 
  geom_bar(aes(x = name, y = item_count), stat = "identity") +
  facet_wrap(~ rank, scales = "free") +
  labs(x = "Taxon", y = "Abundance", title = "Abundance of taxa in a sample of the UNITE database") +
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        panel.grid = element_blank())
```

For ranks with relatively few taxa, this is a satisfactory graphing technique, but it is ineffective once there is more than 20 or so taxa. 
It also is difficult to discern how sub-taxa are distributed within each taxon. 
For example, if we only looked at the phylum or class level, we can easily see that Basidiomycota/Agaricomyctes are the most plentiful, but don't know if that is due to a single highly abundant species, or many moderately abundant species.
These details are typically important for the interpretation of results.  
Pie charts are also commonly used for this purpose, but they are just a less effective version of a bar chart.

```{r, echo=FALSE, fig.width = 6.5, fig.height = 6.5}
ggplot(data[data$rank == "Phylum", ]) + 
  geom_bar(aes(x = factor(1), y = item_count, fill = name), stat = "identity") +
  coord_polar(theta = "y") +
  labs(x = "Taxon", y = "Abundance", title = "Abundance of taxa in a sample of the UNITE database") +
  theme_minimal() +  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        panel.grid = element_blank(), 
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank())
```


`Metacoder` approches this problem by using size and color to represent numeric data distributed along a phylogenetic tree:

```{r, echo=FALSE, fig.width=6.5, fig.height=6.5}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

In this example, both size and color are being used to represent the abundance of taxa.
Using this method, it is clear how child taxa are distributed within their parents and what taxa are unusual (note the unidentified agaricales). 


## Basic usage

Although there are many options that can be used to make highly customized graphs, `plot_taxonomy` only needs two arguments to function. 
These are a list of unique taxon IDs and a corresponding list of IDs of parent taxa (i.e. one rank lower).
These two lists effectively constitute an adjacency/edge list, describing how taxa are connected in a phylogenetic tree. 
We can see the default appearance of the data used in the introduction using the code below.
The `taxa` object is one of the two `data.frame`s returned by the function `extract_taxonomy`, which is covered in [another vignette](extracting_taxonomy_information_from_sequence_headers.html).

```{r, fig.width=6.5, fig.height=6.5}
head(taxon_data(original_data))
plot(original_data)
```

Each vertex (i.e. circle) in the graph represents a taxon and each line represents its membership in a lower taxon. 

### Vertex/Line size

The size of vertices and lines can be scaled to a number associated with each taxon using the `size` parameter. 
Below, the number of sequences for each taxon is used to determine vertex size.

```{r, fig.width=6.5, fig.height=6.5}
plot(original_data,
     vertex_size = item_count)
```

Note that it was not necessary to specify the absolute vertex size; the range of absolute vertex sizes is optimized for each graph so as to minimize overlap of vertices and maximize the ranges of sizes.
The argument `overlap_avoidance` is used to determine how much overlaps are avoided. 
Higher values mean more importance is given to avoiding overlapping vertices than to maximizing the ranges of sizes.
A high `overlap_avoidance` makes the connections between taxa more clear, but diminishes the visual effect of vertex size.
Too low of an `overlap_avoidance` can make the graph hard to read.

```{r}
plot(original_data,
     vertex_size = item_count,
     overlap_avoidance = 10)
plot(original_data,
     vertex_size = item_count,
     overlap_avoidance = 0.1)
```


### Vertex color

The `vertex_color` argument works in a similar way to `size`.
Numeric values are translated to a range of colors.
Below the abundance of samples for each taxon is used to determine color instead of size.
The range of color used can be set using the `vertex_color_series` argument. 
This argument take a list of colors in the form of names, hex color codes, or integers. 

```{r}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count)

plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_color_range = c("#FFFFFF", "darkorange3", "#4e567d", "gold"))
```

### Line color

Unlike `vertex_size`, the color of lines can be set independently of vertices, although the default behavior is for the lines to have the same color as the vertices. 
To only color vertices, you can set the lines to be a constant color or vise-versa.

```{r}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     edge_color = "grey")

plot(original_data,
     vertex_size = item_count,
     vertex_color = "grey",
     edge_color = item_count)
```

You can also set the color palette used for the lines in the same way as you set it for the vertex using the argument `edge_color_range`. 

### Vertex labels 

Labels can be added to vertices using the `vertex_label` option:

```{r, fig.width=6.5, fig.height=6.5}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

Label sizes are proportional to vertex size by default. 
By default, only a maximum number of labels are printed to avoid excessive crowding. 
The maximum number of labels that will be printed is controlled by the `vertex_label_max` option:

```{r}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name,
     vertex_label_max = 5)

plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name,
     vertex_label_max = 100)
```

Note that the labels are a special kind that scales with the size of the graph. 
This means that the text size will always be proportional to the graph size regardless of ow big the graph is rendered; however, these special labels take more time to render, so causing too many to be printed drastically slow the rendering of the graph. 

### Line labels 

Lines can be labeled as well using the `edge_label` option, which works similarly to the `vertex_label` option:

```{r, fig.width=6.5, fig.height=6.5}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     edge_label = name)
```


## Usage examples


### Plotting with multiple taxonomy roots

Sometimes a taxonomy has multiple roots.
This occurs when there is not a common taxon all items are assigned to, like "Eukaryota" if all your items are associated with eukayotes.
When plotting these type of data some might want all the data to share a common "life" root and be on the same tree, whereas others might think it more appropriate to plot each in different trees. 
`metacoder` allows for both of these, but defaults to plotting taxonomies with multiple roots as multiple trees.

#### Default plotting behavior for multiple taxonomic roots

Say someone emails you a list of ncbi ids that you want to plot.
You could use the following code to get the taxonomic information.

```{r, eval=FALSE}
raw <- "JQ086376.1 AM946981.2 JQ182735.1 CP001396.1 J02459.1 AC150248.3 X64334.1 CP001509.3 CP006698.1 AC198536.1 JF340119.2 KF771025.1 CP007136.1 CP007133.1 U39286.1 CP006584.1 EU421722.1 U03462.1 U03459.1 AC198467.1 V00638.1 CP007394.1 CP007392.1 HG941718.1 HG813083.1 HG813082.1 CP007391.1 HG813084.1 CP002516.1 KF561236.1 JX509734.1 AP010953.1 U39285.1 M15423.1 X98613.1 CP006784.1 CP007393.1 CU928163.2 AP009240.1 CP007025.1 CP006027.1 CP003301.1 CP003289.1 CP000946.1 CP002167.1 HG428755.1 JQ086370.1 CP001846.1 CP001925.1 X99439.1 AP010958.1 CP001368.1 AE014075.1 CP002212.1 CP003034.1 CP000243.1 AY940193.1 CP004009.1 JQ182732.1 U02453.1 AY927771.1 BA000007.2 CP003109.1 CP007390.1 U02426.1 U02425.1 CP006262.1 HG738867.1 U00096.3 FN554766.1 CP001855.1 L19898.1 AE005174.2 FJ188381.1 AK157373.1 JQ182733.1 U39284.1 U37692.1 AF129072.1 FM180568.1 CP001969.1 HE616528.1 CP002729.1 JF974339.1 AB248924.1 AB248923.1 CP002291.1 X98409.1 CU928161.2 CP003297.1 FJ797950.1 CP000038.1 U82598.1 CP002211.1 JQ806764.1 U03463.1 CP001665.1"
ids <- strsplit(raw, " ")[[1]]
contaminants <- extract_taxonomy(ids, regex = "(.*)", key = c(name = "item_id"))
```

In order to avoid using the NCBI servers more than necessary (and to avoid waiting), I saved the result of above code in an included example data set called `contaminants`.
The code below will use the included data set if the code above is not run (you don't need to run it to do the plotting). 

```{r, fig.width = 6.5, fig.height = 6.5}
plot(contaminants,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

### Spltting a taxonomy into multiple trees

You can also take a taxonomy with a single root and display it by splitting it at a specified level/rank. 

```{r}
file_path <- system.file("extdata", "unite_general_release.fasta", package = "metacoder")
sequences <- ape::read.FASTA(file_path)
cat(names(sequences)[1])
original_data <- extract_taxonomy(names(sequences),
                         regex = "^(.*)\\|(.*)\\|(.*)\\|.*\\|(.*)$",
                         key = c(name = "item_info", seq_id = "item_info",
                                 other_id = "item_info", "class_name"),
                         database = "none")
```


```{r, fig.width = 6.5, fig.height = 6.5}
plot(original_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```


```{r}
plot(original_data[name == "Ascomycota"],
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)

plot(original_data[level > 1],
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

