---
title: "Creating a taxonomically balanced sequence set"
output:
  rmarkdown::html_vignette:
    toc: false
    css: custom.css
vignette: >
  %\VignetteIndexEntry{Creating a taxonomically balanced sequence set}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(ape)
library(metacoder)
library(knitr)
opts_chunk$set(dev='svg', fig.width = 7.1, fig.height = 7.1, warning=FALSE, message=FALSE, eval = FALSE)
```

## Introduction

There are three primary taxonomy-specific criteria that should be met when creating an ideal set of reference sequences for evaluating metabarcoding primers.
I say "taxonomy-specific" because there are obviously other considerations that deal with sequence characteristics, such as quality and the presence of primer binding sites, but these will be dealt with separately.

The three taxonomy-specific criteria are: 

1. **taxonomic coverage**: All taxa of interest should be represented by enough sequences to capture their diversity.
2. **balance**: The number of sequences for each sub-taxon should be approximately equal, so that estimates for the parent taxon are not biased for a particular child. 
3. **size**: A reference sequence set should be the minimum size that meets the above two criteria, since this allows for computationally intense analysis. 

When evaluating potential primers for metabarcoding experiments it is important to have reference sequences representative of every taxon of interest.
The number of sequences of each taxon at each taxonomic level should be approximately equal, or perhaps more accurately, proportional to the diversity within that taxon.
If the sequence of a given locus correlates with characters used to determine taxonomy, as is the case for an ideal barcoding locus, the number of sub-taxa should be proportional to diversity of a given taxon. 

Random samples of online sequence databases typically do have these characteristics, even those designed for metabarcoding. 
Sequences are not available for many taxa and the numbers of sequences vary dramatically for different taxa. 
For these reasons, a simple random sample of sequences for a given taxon from an online database will often not constitute an ideal reference sequence set. 
Therefore, `metacoder` includes functions to extract a sample of reference sequences that meet these criteria from a larger set of sequences. 
There are two main ways to accomplish this using `metacoder`. 

* **Taxonomically-balanced sub-sample:** Functions `extract_taxonomy` and `taxonomic_sample` can be used to parse taxonomy information from a sequence file (e.g. from FASTA headers with Genbank ids) and the sub-sample/re-sample the data to make it taxonomically balanced.
* **Taxonomically-balanced Genbank download:** A function called `ncbi_taxon_sample` can be used to identify and download a set of sequences for a given taxon and custom Genbank query. 

## Usage examples

`taxonomic_sample` and `ncbi_taxon_sample` have similar arguments and behaviors. 
Both use recursion to search through a taxonomic tree while sub-sampling taxa and items (e.g. sequences) that have a taxonomic classification. 
Both can return a samples of a given size by controlling how many items (e.g. sequences) are allowed/required at each taxonomic rank (e.g. genus)
They differ in what they are best used for. 
`taxonomic_sample` is good for use on downloaded copies of curated databases, such as [UNITE](https://unite.ut.ee/) or [RDP](http://rdp.cme.msu.edu/seqmatch/seqmatch_intro.jsp), especially ones that have embedded classifications for each sequence (i.e. something like `k__Fungi;p__Ascomycota;c__Leotiomycetes` in the headers). 
`ncbi_taxon_sample` is good for downloading sparse informal surveys of large taxonomic groups (e.g. all fungi) without having to download every sequence. 

### Using `taxonomic_sample`

`taxonomic_sample` is used to sample items according to their taxonomic classifications. 
These items must have a unique taxon id and an associated taxonomy defining how these taxon ids are related. 
The example below uses `extract_taxonomy` to get this information; the use of this function is explained in the vignette about extracting taxonomy information from sequence metadata.

```{r parse_data}
library(metacoder)
file_path <- system.file("extdata", "unite_general_release.fasta", package = "metacoder")
sequences <- ape::read.FASTA(file_path) # Reads an example FASTA file
names(sequences)[1] # Print an example of the sequence header format
unite_ex_data_3 <- extract_taxonomy(names(sequences), # Parse the sequence headers
                                    regex = "^(.*)\\|(.*)\\|(.*)\\|.*\\|(.*)$",
                                    key = c(name = "item_info", seq_id = "item_info",
                                            other_id = "item_info", "class_name"),
                                    database = "none")
```

At this point, the taxonomy information has been extracted from the sequences headers. 
`items` is a `data.frame` with rows corresponding to sequences. 
One column in `items` is the taxon id; this is the only column we will use from `items`.
The other item returned from `extract_taxonomy` is `taxa`.
`taxa` is a `data.frame` with rows for each unique taxon use in the item classifications. 

If we look at how sequences are distributed throughout the taxonomy, we can see that Ascomycota and Basidiomycota comprise the majority of the sequences, even though three other fungal phyla are also present.
Depending on the goal, this might or might not be a problem.
The overepresentation of Agaricales is likely a bigger problem. 

```{r all_data}
plot(data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

Information from both these tables is needed to make a taxonomically balanced subset of `items`.
The first step is to use the taxonomy tree structure stored in `taxa` (in the form of an adjacency/edge list) to sub-sample `items`.
Then, `taxa` is sub-sampled using `restrict_taxonomy` to remove any taxa not associated with items in the subset.

To try to reduce the Agaricales overepresentation, we will sub-sample any order with greater than 20 sequences to 20 sequences.
Similarly, species will be sub-sampled to 5 sequences each to avoid any one species introducing bias.
The `max_counts = c("o" = 20, "s" = 5)` option is used to implement the sub-sampling limits for each taxonomic rank (encoded by single letters for this specific data set). 

It might also be desirable to not included sequences from underrepresented taxa.
Too few sequences means that the diversity of the taxon cannot be determined and questionable sequences are not as obvious without others of the same classification to compare them to.
For this reason, we will use the option `min_counts = c("s" = 3)`, so items from species with less than 3 items will not be included.

```{r}
index <- taxonomic_sample(root_id = "1", item_ids = items$taxon_id, taxon_ids = taxa$taxon_id,
                          parent_ids = taxa$parent_id, ranks = taxa$rank, max_counts = c("o" = 20, "s" = 5),
                          min_counts = c("s" = 3))
sampled_items <- items[index, ] # Subsample sequence metadata
sampled_taxa_index <- restrict_taxonomy(taxa = taxa$taxon_id, # Find which taxa are still used in the subset
                                         parents = taxa$parent_id,
                                         subset = sampled_items$taxon_id)
sampled_taxa <- taxa[sampled_taxa_index, ] # Subsample the taxa to only those in the subset of items 
sampled_taxa$item_count <- get_taxon_count(sampled_taxa$taxon_id, # Count how many items are in each taxon
                                           sampled_taxa$parent_id,
                                           sampled_items$taxon_id)
```

We can now view the difference between the original and sub-sampled data sets using `plot_taxonomy` again.

```{r subset_1}
plot(sampled_data,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = ifelse(rank %in% c("s", "o"), item_count, NA),
     edge_label = ifelse(rank == "o", name, NA))
```


### Using `ncbi_taxon_sample`

Although, downloading a data set, parsing it with `extract_taxonomy`, and sub-sampling with `taxonomic_sample` is the best method for most analyses, it is also possible to download a taxonomically balanced random set of sequences from Genbank without downloading all of the sequences for the group of interest.
This is done using the function `ncbi_taxon_sample`. 
Internally, `ncbi_taxon_sample` is very similar to `taxonomic_sample`, except that it queries Genbank for taxonomy and sequence information instead of getting it from parsed data. 
This function is best used for getting a small number of sequences over diverse taxonomic groups for informal analyses. 
If it is feasible to download all of the group of interest, it is likely best to use `extract_taxonomy` + `taxonomic_sample` instead of `ncbi_taxon_sample`.


```{r, results='hide', eval=FALSE}
sequence_data <- ncbi_taxon_sample(name = "fungi", target_rank = "phylum", 
                           max_counts = c(phylum = 30), 
                           entrez_query = "18S[All Fields] AND 28S[All Fields]",
                           min_length = 600, max_length = 10000)
ncbi_fungi_sample <- extract_taxonomy(sequence_data$gi_no, regex = "(.*)", key = "item_id")
```


```{r}
plot(ncbi_fungi_sample,
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = ifelse(rank == "phylum", name, item_count))
```

