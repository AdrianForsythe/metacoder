legend.position="none",
panel.background=element_blank(),
panel.border=element_blank(),
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
plot.background=element_blank())
if (!is.null(save_png)) {
png(file = save_png, bg = background)
print(my_plot)
dev.off()
}
if (display) {
print(my_plot)
}
return(my_plot)
}
#===================================================================================================
#' plot_distance_distribution
#'
#' @importFrom zoo rollmean
#' @importFrom reshape2 melt
#' @import ggplot2
plot_distance_distribution <- function(input, title=NULL, save_png=NULL, display=FALSE, background="transparent", smoothness=3, bin_width=NULL) {
if (class(input) == "character" || class(input) == "factor" ) {
if (file.exists(as.character(input))) {
data <- read.csv(as.character(input), sep="\t")
} else {
stop("Cannot read input file.")
}
} else if (class(input) == "data.frame") {
data <- input
} else {
stop("Invalid input class. data.frame required.")
}
#infer bin width from adjacent count values
if (is.null(bin_width)) {
bin_width <- data$count_middle[2] - data$count_middle[1]
}
#scale same and diffent measurments to equal area relative to total (invalidates y axis)
if (smoothness > nrow(data)) {
smoothness <-  nrow(data)
}
if (sum(data$same) != 0 && sum(data$different) != 0) {
data$same <- data$same * (sum(data$total) / sum(data$same))
data$different <- data$different * (sum(data$total) / sum(data$different))
}
if (nrow(data) > smoothness && sum(data$same) != 0 && sum(data$different) != 0) {
#Apply a moving average relative to differences in standard deviation
different_window <- (1 + as.integer(sd(data$different) / sd(data$same))) * smoothness
same_window <- (1 + as.integer(sd(data$same) / sd(data$different))) * smoothness
} else {
same_window <- smoothness
different_window <- smoothness
}
if (different_window >= nrow(data)) {
different_window <- nrow(data) - 1
}
if (same_window >= nrow(data)) {
same_window <- nrow(data) - 1
}
if (different_window > 1 && sum(data$different) != 0) {
data$different <- rollmean(data$different, different_window, fill="extend")
}
if (same_window > 1 && sum(data$same) != 0) {
data$same <- rollmean(data$same, same_window, fill="extend")
}
#plot data
data <- melt(data, measure.vars=2:ncol(data), id.vars = 1,  na.rm=TRUE)
if (all(c("different", "same") %in% data$variable)) { #if the same and different columns are present (typical)
data <- data[data$variable != "total", ]
my_plot <- ggplot(data, aes(x=count_middle, y=value)) +
geom_bar(aes(fill = variable), alpha = .5, position='identity', stat="identity", width=bin_width)
} else {
my_plot <- ggplot(data, aes(x=count_middle, y=value)) +
geom_bar(fill="grey", alpha = .7, position='identity', stat="identity", width=bin_width)
}
my_plot <- my_plot +
labs(title=title) +
theme(title=element_text(size=30),
axis.line=element_blank(),
axis.title=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
legend.position="none",
panel.background=element_blank(),
panel.border=element_blank(),
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
plot.background=element_blank())
if (!is.null(save_png)) {
png(file = save_png, bg = background)
print(my_plot)
dev.off()
}
if (display) {
print(my_plot)
}
return(my_plot)
}
#===================================================================================================
#' Makes igraph from images
#'
#' @importFrom igraph graph.edgelist V get.shortest.paths E
plot_image_tree <- function(graph, image_file_paths, labels=NA, scaling=1, exclude=c(), root_index=1, label_color = "black") {
#store the distance of all verticies and edges from the root
root <- V(graph)[root_index]
vertex_depth <- sapply(get.shortest.paths(graph, from=root)$vpath, length)
edge_depth <- vertex_depth[get_edge_parents(graph)]
#set vertex graphing parameters
V(graph)$size <- (log(scaling + .5) / max(log(scaling) + .5)) * 10
if (is.na(labels)) {
V(graph)$label.cex <- 0
} else {
V(graph)$label <- labels
V(graph)$label.cex <- V(graph)$size * .05 + .15
V(graph)$label.color <- label_color
}
V(graph)$alpha <- (max(vertex_depth)*1.5 - vertex_depth) / (max(vertex_depth)*1.5)
V(graph)$raster_file <- image_file_paths #not used in disaply, but should be subset below
#set edge graphing parameters
E(graph)$width <- V(graph)$size[get_edge_children(graph)] * 5
E(graph)$color <- sapply(((max(edge_depth)*4 - edge_depth) / (max(edge_depth)*4)) * .3,
function(x) rgb(red=.3,green=.3,blue=.3,alpha=x))
#exclude specific verticies and their decendents from display
graph <- delete_vetices_and_children(graph, exclude)
#Calculate vertex layout
graph_layout <- layout.reingold.tilford(graph, root = root_index, circular = TRUE)
#Load vertex images
V(graph)$raster <- lapply(as.character(V(graph)$raster_file), readPNG)
#plot graph
my_plot <- plot(graph,
layout=graph_layout,
margin=0,
vertex.label.dist=0,
vertex.label.degree=0,
vertex.label=labels,
edge.arrow.size =0,
vertex.shape="raster",
vertex.size=V(graph)$size*1.5,
vertex.size2=V(graph)$size*1.5)
if (display) {
print(my_plot)
}
return(plot)
}
#===================================================================================================
#' Makes igraph from values
#'
#' @importFrom igraph graph.edgelist V get.shortest.paths E
#' @export
plot_value_tree <- function(graph, values, labels=NA, scaling=1, exclude=c(), root_index=1, label_color = "black", display=FALSE, fade=FALSE, legend_text="", value_range=c(0,1), highlight_outliers=TRUE, background="#00000000", save=NULL) {
init_igraph()
#make graph if nessesary
if (class(graph) == "character") {
graph <- graph.edgelist(taxon_edge_list(graph, ";"))
} else if (class(graph) != "igraph") {
stop("Incorrect input. 'graph' must be an igraph object or a list of taxonomy strings.")
}
#store the distance of all verticies and edges from the root
root <- V(graph)[root_index]
vertex_depth <- sapply(get.shortest.paths(graph, from=root)$vpath, length)
edge_depth <- vertex_depth[get_edge_parents(graph)]
#set vertex graphing parameters
V(graph)$size <- (log(scaling + .5) / max(log(scaling) + .5)) * 10
if (is.na(labels)) {
V(graph)$label.cex <- 0
} else if (labels == TRUE) {
V(graph)$label <- as.character(signif(values, 2))
V(graph)$label.cex <- V(graph)$size * .45 + .15
V(graph)$label.color <- label_color
} else {
V(graph)$label <- labels
V(graph)$label.cex <- V(graph)$size * .45 + .15
V(graph)$label.color <- label_color
}
if (fade == TRUE) {
V(graph)$alpha <- (max(vertex_depth)*1.5 - vertex_depth) / (max(vertex_depth)*1.5)
} else if (fade == FALSE) {
V(graph)$alpha <- 1
} else {
V(graph)$alpha <- fade
}
V(graph)$values <- values
#set edge graphing parameters
E(graph)$width <- V(graph)$size[get_edge_children(graph)] * 5
E(graph)$color <- sapply(((max(edge_depth)*4 - edge_depth) / (max(edge_depth)*4)) * .3,
function(x) rgb(red=.3,green=.3,blue=.3,alpha=x))
#exclude specific verticies and their decendents from display
graph <- delete_vetices_and_children(graph, exclude)
#set vertex color
color_values <- V(graph)$values
value_range_quantile <- quantile(color_values, value_range, na.rm=TRUE)
if (highlight_outliers) {
outliers <- color_values < value_range_quantile[1] | color_values > value_range_quantile[2]
V(graph)$frame.width <- ifelse(outliers, 25, .05)
}
outliers <- color_values < value_range_quantile[1] | color_values > value_range_quantile[2]
V(graph)$frame.width <- ifelse(outliers, 25, .05)
color_values[color_values < value_range_quantile[1]] <- value_range_quantile[1]
color_values[color_values > value_range_quantile[2]] <- value_range_quantile[2]
V(graph)$color=mapply(add_alpha,
color.scale(color_values, c(1,0,0), c(0,1,0), c(0,0,1), xrange=c(min(color_values), max(color_values))),
alpha=V(graph)$alpha)
#Calculate vertex layout
graph_layout <- layout.reingold.tilford(graph, root = root_index, circular = TRUE)
#Load vertex images
V(graph)$raster <- lapply(as.character(V(graph)$raster_file), readPNG)
if (!is.null(save)) {
png(file = save, bg = background, width=5000, height=5000)
}
#plot graph
my_plot <- plot(graph,
layout=graph_layout,
margin=0,
vertex.label.dist=0,
vertex.label.degree=0,
edge.arrow.size =0,
vertex.shape="fcircle",
vertex.frame.color='black')
#Make legend (http://stackoverflow.com/questions/12041042/how-to-plot-just-the-legends-in-ggplot2)
#   legend <- continuous_color_legend(color_values,
#                                     low=V(graph)$color[which.min(color_values)],
#                                     mid=V(graph)$color[which_middle(color_values)],
#                                     high=V(graph)$color[which.max(color_values)],
#                                     name=legend_text,
#                                     background=background)
#   pushViewport(viewport(x=0.9, y=0.15))
#   grid.draw(legend)
if (!is.null(save)) {
dev.off()
}
return(my_plot)
}
#===================================================================================================
#' plot_value_distribution_by_level
#'
#' @import ggplot2
plot_value_distribution_by_level <- function(taxon_data, value_column, level_column = "level", ...) {
ggplot(taxon_data, aes_string(x=level_column, y=value_column)) +
geom_boxplot(width=.5, outlier.colour="transparent") +
geom_violin(alpha=.4, aes_string(fill=level_column,  colour = level_column)) +
geom_point(position = position_jitter(w = 0.1, h = 0), alpha = .2) +
facet_grid(~ clustering_level, scales = "free_x", space="free_x")  +
labs(...) +
theme(title=element_text(size=17),
axis.text.y=element_text(size=12),
axis.text.x=element_text(size=12, angle = 60, hjust = 1),
axis.title=element_text(size=20),
legend.position="none",
panel.background=element_blank(),
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
plot.background=element_blank(),
strip.text.x = element_text(size = 12))
}
plot_value_tree(nodes, proportion)
### Generic internal functions
#===================================================================================================
#' offset_ordered_factor
offset_ordered_factor <- function(ordered_factor, offset) {
my_levels <-  levels(ordered_factor)
new_level <- my_levels[which(my_levels == ordered_factor) + offset]
ordered(new_level, my_levels)
}
#===================================================================================================
#' fapply
fapply <- function(iterable, functions,
.preprocessor={function(x) x},
.preprocessor_args=list(),
.allow_complex=TRUE,
...) {
apply_functions <- function(input, functions, ...) {
if (!is.list(input)) {
input <- list(input)
}
input <- append(input, list(...))
results <- lapply(functions, function(f) do.call(f, input))
atomics <- which(!sapply(results, is.recursive))
if (length(atomics) > 0) {
results[atomics] <- lapply(1:length(atomics), function(i) {y <- list(results[[atomics[i]]]);
names(y) <- functions[i];
y})
}
results <- unlist(results, recursive=FALSE)
if (!.allow_complex) {
results <- results[!sapply(results, is.recursive)]
}
return(results)
}
if (length(iterable) < 1) {
return(NULL)
}
if (is.data.frame(iterable) | is.matrix(iterable)) {
iterable_length <- length(iterable[[1]])
row_names <- row.names(iterable)
call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[i,]), .preprocessor_args))}
} else if (is.list(iterable)) {
iterable_length <- length(iterable)
row_names <- unlist(iterable)
call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[[i]]), .preprocessor_args))}
} else {
iterable_length <- length(iterable)
row_names <- iterable
call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[i]), .preprocessor_args))}
}
output <- lapply(1:iterable_length, function(i) apply_functions(call_preprocessor(i), functions, ...))
column_names <- names(output[[1]])
output <- lapply(1:length(output[[1]]), function(i) lapply(output, function(row) row[[i]]))
output <- lapply(output, function(x) if (!is.recursive(x[[1]])) {unlist(x, recursive=FALSE)} else {I(x)})
output <- do.call(data.frame, output)
colnames(output) <- column_names
row.names(output) <- row_names
return(output)
}
#===================================================================================================
#' remove_all_na_rows
remove_all_na_rows <- function(input) {
na_rows <- sapply(1:nrow(input), function(x) sum(!is.na(input[x,])) != 0)
input[na_rows, ]
}
#===================================================================================================
#' remove_outliers
remove_outliers <- function(x, na.rm = TRUE, ...) {
qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
H <- 1.5 * IQR(x, na.rm = na.rm)
y <- x
y[x < (qnt[1] - H)] <- NA
y[x > (qnt[2] + H)] <- NA
y
}
#===================================================================================================
#' which_median
which_median <- function(x) which.min(abs(x - median(x)))
#===================================================================================================
#' which_middle
which_middle <- function(x) {
middle <- (max(x) + min(x)) / 2
which.min(abs(x - middle))
}
### File system functions
#===================================================================================================
#' rm_ext
rm_ext <- function(file) {
sub("[.][^.]*$", "", file, perl=TRUE)
}
#===================================================================================================
#' next_incremental_file_number
next_incremental_file_number <-function(directory) {
current_numbers <- as.integer(rm_ext(list.files(directory, no..=TRUE)))
if (length(current_numbers) == 0) {
current_numbers = 0
}
max(current_numbers) + 1
}
### iGraph-associated functions
#===================================================================================================
#' under development
#'
#' @export
taxon_edge_list <- function(taxonomy, separator) {
get_taxon_edge_list <- function(taxon) {
apply(matrix(c(1:(length(taxon)-1),2:length(taxon)), ncol = 2), 1, function(x) c(taxon[x[1]], taxon[x[2]]))
}
taxons <- unique(taxonomy)
taxons <- strsplit(taxons, separator, fixed=TRUE)
taxons <- taxons[sapply(taxons, length) > 1]
taxons <- lapply(taxons, function(x) sapply(seq(1, length(x)), function(y) paste(x[1:y], collapse=separator)))
edge_list <- t(do.call(cbind,lapply(taxons, FUN=get_taxon_edge_list)))
edge_list[!duplicated(edge_list),]
}
#===================================================================================================
#' get_edge_parents
#' @importFrom igraph get.edges ecount
get_edge_parents <-function(graph) {
get.edges(graph, 1:ecount(graph))[,1]
}
#===================================================================================================
#' get_edge_children
#' @importFrom igraph get.edges ecount
get_edge_children <- function(graph) {
get.edges(graph, 1:ecount(graph))[,2]
}
#===================================================================================================
#' get_vertex_children
#' @importFrom igraph shortest.paths V
get_vertex_children <- function(graph, vertex) {
which(shortest.paths(graph, V(graph)[vertex], mode="out") != Inf)
}
#===================================================================================================
#' delete_vetices_and_children
#' @importFrom igraph delete.vertices
delete_vetices_and_children <- function(graph, vertices) {
#delete children
vertices <- unlist(sapply(vertices, function(x) get_vertex_children(graph, x)))
graph <- delete.vertices(graph, vertices)
return(graph)
}
### Generic ploting functions
#===================================================================================================
#' add_alpha
add_alpha <- function(col, alpha=1){
apply(sapply(col, col2rgb)/255, 2,
function(x)
rgb(x[1], x[2], x[3], alpha=alpha))
}
### iGraph-associated plotting functions
#===================================================================================================
#' mycircle generator
#'
#' @export
mycircle <- function(coords, v=NULL, params) {
vertex.color <- params("vertex", "color")
if (length(vertex.color) != 1 && !is.null(v)) {
vertex.color <- vertex.color[v]
}
vertex.size  <- 1/200 * params("vertex", "size")
if (length(vertex.size) != 1 && !is.null(v)) {
vertex.size <- vertex.size[v]
}
vertex.frame.color <- params("vertex", "frame.color")
if (length(vertex.frame.color) != 1 && !is.null(v)) {
vertex.frame.color <- vertex.frame.color[v]
}
vertex.frame.width <- params("vertex", "frame.width")
if (length(vertex.frame.width) != 1 && !is.null(v)) {
vertex.frame.width <- vertex.frame.width[v]
}
mapply(coords[,1], coords[,2], vertex.color, vertex.frame.color,
vertex.size, vertex.frame.width,
FUN=function(x, y, bg, fg, size, lwd) {
symbols(x=x, y=y, bg=bg, fg=fg, lwd=lwd,
circles=size, add=TRUE, inches=FALSE)
})
}
#===================================================================================================
#' initialize igraph
#'
#' @import igraph
#' @export
init_igraph <- function() {
add.vertex.shape("fcircle",
plot=mycircle,
parameters=list(vertex.frame.color=1, vertex.frame.width=1))
}
#===================================================================================================
#' make a color legend
#'
#' @import ggplot2
my_continuous_color_legend <- function(values, background="#00000000", ...) {
#Extract Legend (http://stackoverflow.com/questions/12041042/how-to-plot-just-the-legends-in-ggplot2)
g_legend<-function(a.gplot){
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
return(legend)}
mid_point = (max(values) + min(values)) / 2
label_points <- seq(min(values), max(values), length.out=7)
labels <- as.character(signif(label_points, 2))
full_plot <- qplot(x,y, colour=value, data=data.frame(x=1, y=1, value=values)) +
scale_colour_gradient2(breaks = label_points, labels = labels, midpoint=mid_point, ...) +
theme(legend.key.size = unit(5, "cm"),
legend.text = element_text(size=85),
legend.title = element_text(size=85),
legend.background = element_rect(fill = background))
g_legend(full_plot)
}
#===================================================================================================
#' get nodes from leafs
#'
#' @export
get_nodes_from_leafs <- function(leafs, sep = ";") {
if (is.atomic(leafs)) leafs <- strsplit(leafs, sep, fixed=TRUE)
taxons <- lapply(leafs, function(x) sapply(seq(1, length(x)), function(y) paste(x[1:y], collapse=sep)))
unique(unlist(taxons))
}
#===================================================================================================
#' count nodes in leafs
#'
#' @export
count_nodes_in_leafs <- function(leafs, nodes = NULL, sep = ";") {
if (is.null(nodes)) nodes <- get_nodes_from_leafs(leafs, sep = sep)
vapply(nodes, function(x) sum(grepl(x, leafs, fixed = TRUE)), numeric(1))
}
plot_value_tree(nodes, proportion)
library(igraph)
plot_value_tree(nodes, proportion)
library(metacoder)
plot_value_tree(nodes, proportion)
library(metacoder)
library(metacoder)
add.vertex.shape("fcircle",
plot=mycircle,
parameters=list(vertex.frame.color=1, vertex.frame.width=1))
igraph::add.vertex.shape("fcircle",
plot=mycircle,
parameters=list(vertex.frame.color=1, vertex.frame.width=1))
?unit
?ggplot2::unit
?ggplot::unit
library(ggplot2)
?unit
unit
element_text
unit(5, "cm")
png
igraph::.igraph.pars
library(igraph)
.igraph.pars
add.vertex.shape("fcircle",
plot=mycircle,
parameters=list(vertex.frame.color=1, vertex.frame.width=1))
library(metacoder)
