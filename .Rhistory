#' @export
distance_distribution <- function(distance, identity=NULL, distance_bin_width=0.001, output_file_path=NULL,  plot_file_path=NULL, name=NULL, ...) {
output <- list()
if (is.null(identity)) {
identity = sapply(rownames(distance), function(x) colnames(distance) == x)
}
#Validate input data
is_valid_input = is.matrix(distance) && sum(!is.na(distance)) > 0
#Calculate distance distribution
if (is_valid_input) {
breaks <- seq(as.integer(min(distance, na.rm=TRUE) / distance_bin_width),
as.integer(max(distance, na.rm=TRUE) / distance_bin_width) + 1)
breaks <- breaks * distance_bin_width
total_hist <- hist(distance, plot=FALSE, breaks=breaks)
distance_distribution <- data.frame(count_middle=total_hist$mids, total=total_hist$counts)
distance_distribution$same <- hist(distance[identity], plot=FALSE, breaks=breaks)$counts
if (length(unique(rownames(distance))) >= 2) {
distance_distribution$different <- hist(distance[!identity], plot=FALSE, breaks=breaks)$counts
} else {
distance_distribution$different <- 0
}
} else {
distance_distribution <- NA
}
output$distance_distribution <- distance_distribution
#write output data
if (!is.null(output_file_path)) {
if (is_valid_input) {
if (file.exists(output_file_path) && file.info(output_file_path)$isdir) {
file_path <- taxon_output_path_preparation(output_file_path,
sub_directory=as.character(match.call()[[1]]),
ext=".txt",
name = name,
...)
} else {
file_path <- output_file_path
}
write.table(format(distance_distribution, scientific = FALSE) , file=file_path, sep="\t", quote=FALSE, row.names=FALSE)
} else {
file_path <- NA
}
output$distance_distribution_file <- file_path
}
#Make plot of output data
if (!is.null(plot_file_path)) {
if (is_valid_input) {
if (file.exists(plot_file_path) && file.info(output_file_path)$isdir) {
file_path <- taxon_output_path_preparation(output_file_path,
sub_directory=as.character(match.call()[[1]]),
ext=".png",
name = name,
...)
} else {
file_path <- plot_file_path
}
my_plot <- plot_distance_distribution(output$distance_distribution,
save_png = file_path,
title = name,
bin_width=distance_bin_width)
} else {
file_path <- NA
}
output$threshold_optimization_plot_path <- file_path
}
return(output)
}
#===================================================================================================
#' Optimize clustering threshold
#' @export
#' @importFrom spider threshOpt
#' @importFrom plyr ldply
threshold_optimization <- function(distance, threshold_resolution=0.001, output_file_path=NULL, plot_file_path=NULL, name=NULL, ...) {
output <- list()
#Validate input data
is_valid_input = length(unique(rownames(distance))) >= 2
if (is_valid_input) {
#convert lower tri matrix to full
distance[upper.tri(distance, diag=TRUE)] <- t(distance)[upper.tri(distance, diag=TRUE)]
diag(distance) <- 0
#Calulate threshold error rates
min_x <- 0
#     max_x = quantile(distance, .8, na.rm=TRUE, type=3)
max_x <- max(distance)
threshold <- seq(min_x, max_x, by = threshold_resolution)
#     my_test <<- distance
statistics <- lapply(threshold, function(x) threshOpt(distance, row.names(distance), thresh = x))
statistics <- ldply(statistics)
colnames(statistics) <- c("threshold", "true_negative", "true_positive", "false_negative", "false_positive", "cumulative_error")
output$optimal_error <- min(statistics$cumulative_error)
optimal_index <- which(output$optimal_error == statistics$cumulative_error)
output$optimal_threshold <- mean(statistics[optimal_index,'threshold'], rm.na=TRUE)
output$optimal_false_negative <- statistics[optimal_index[1],'false_negative']
output$optimal_false_positive <- statistics[optimal_index[length(optimal_index)], 'false_positive']
output$threshold_optimization <- statistics
} else {
output$optimal_error <- NA
output$optimal_threshold <- NA
output$optimal_false_negative <- NA
output$optimal_false_positive <- NA
output$threshold_optimization <- NA
}
#write output data
if (!is.null(output_file_path)) {
if (is_valid_input) {
if (file.exists(output_file_path) && file.info(output_file_path)$isdir) {
file_path <- taxon_output_path_preparation(output_file_path,
sub_directory=as.character(match.call()[[1]]),
ext=".txt",
name = name,
...)
} else {
file_path <- output_file_path
}
write.table(format(statistics, scientific = FALSE), file=file_path, sep="\t", quote=FALSE, row.names=FALSE)
} else {
file_path <- NA
}
output$threshold_optimization_file <- file_path
}
#Make plot of output data
if (!is.null(plot_file_path)) {
if (is_valid_input) {
if (file.exists(plot_file_path) && file.info(output_file_path)$isdir) {
file_path <- taxon_output_path_preparation(output_file_path,
sub_directory=as.character(match.call()[[1]]),
ext=".png",
name = name,
...)
} else {
file_path <- plot_file_path
}
my_plot <- plot_threshold_optimization(output$threshold_optimization,
save_png = file_path,
title = name)
} else {
file_path <- NA
}
output$threshold_optimization_plot_path <- file_path
}
return(output)
}
#===================================================================================================
#' Calculate barcode statistics
#'
#' @export
calculate_barcode_statistics <- function(distance_matrix,
taxonomy_levels = get_taxonomy_levels(),
saved_output_path = getwd(),
level_to_analyze = 'Species',
distance_type = 'distance',
max_sequences_to_compare = 500,
return_raw_data = FALSE,
#                                          remove_na_rows = TRUE,
save_statistics = FALSE,
save_raw_data = FALSE,
save_plots = FALSE,
taxonomy_separator = ';',
functions_to_apply = list("overall_statistics",
"intertaxon_statistics",
"intrataxon_statistics",
"distance_distribution",
"threshold_optimization"),
...) {
distance_matrix <- as.matrix(distance_matrix)
#If the metric is similarity (ie 1=same instead of 0), convert to distance
if (distance_matrix[1,1] == 1) {
distance_matrix = 1 - distance_matrix
}
#Prepare output directory and paths
output_prefix <-  paste(distance_type, '_', taxonomy_levels[level_to_analyze], sep='')
if(save_raw_data || save_plots) {
data_output_directory_name <- paste(output_prefix, '_raw_data', sep='')
data_output_directory <- file.path(saved_output_path, data_output_directory_name, fsep = .Platform$file.sep)
if (!file.exists(data_output_directory)) {
dir.create(data_output_directory, recursive=TRUE)
}
}
if (save_raw_data) {
raw_data_output_directory = data_output_directory
} else {
raw_data_output_directory = NULL
}
if (save_plots) {
plot_output_directory = data_output_directory
} else {
plot_output_directory = NULL
}
#Calculate taxonomy statistics
taxonomy_data <- taxon_info(row.names(distance_matrix), names(taxonomy_levels))
taxonomy_data <- taxonomy_data[order(taxonomy_data$level), ]
taxonomy_data$id <- 1:nrow(taxonomy_data)
#apply functions to subsets of distance matrix for each taxon (CAN TAKE LONG TIME)
get_stat_function_arguments <- function(data_frame_row, ...) {
distance <- subsample_by_taxonomy(distance_matrix, row.names(data_frame_row), data_frame_row$level, names(taxonomy_levels), ...)
list(distance,
identity = sapply(rownames(distance), function(x) colnames(distance) == x),
name = data_frame_row$name,
title = data_frame_row$name,
id = data_frame_row$id,
level_name = taxonomy_levels[data_frame_row$level])
}
taxon_statistics <- fapply(taxonomy_data, functions_to_apply,
.preprocessor = get_stat_function_arguments,
.preprocessor_args = list(level_to_analyze = level_to_analyze,
max_subset = max_sequences_to_compare),
.allow_complex = return_raw_data,
output_file_path = raw_data_output_directory,
plot_file_path = plot_output_directory,
...)
taxon_statistics <- cbind(taxonomy_data, taxon_statistics)
#   #Remove rows that are all NA
#   if (remove_na_rows) {
#     taxon_statistics <- remove_all_na_rows(taxon_statistics)
#   }
#Calculate statistics derived from other statistics
taxon_statistics$inter_intra_differnece <- taxon_statistics$intertaxon_distance_mean - taxon_statistics$intrataxon_distance_mean
taxon_statistics$optimal_error <- (taxon_statistics$optimal_false_negative + taxon_statistics$optimal_false_positive) / taxon_statistics$subsampled_count
if (save_statistics) {
taxon_statistics_output_name = paste('taxon_statistics', '_', output_prefix, '.txt', sep='')
taxon_statistics_output_path =  file.path(saved_output_path, taxon_statistics_output_name, fsep = .Platform$file.sep)
complex_column <- sapply(taxon_statistics, is.recursive)
write.table(taxon_statistics[,!complex_column], file=taxon_statistics_output_path, sep="\t", quote=FALSE, col.names=NA)
}
return(taxon_statistics)
}
stats <- calculate_barcode_statistics(dist_matrix,
level_to_analyze="Species",
saved_output_path = "~/test",
save_statistics = TRUE,
save_raw_data = TRUE,
save_plots = TRUE,
distance_bin_width = 0.001,
threshold_resolution = 0.001)
View(stats)
plot_value_tree(nodes, pcr_proportions, background="#FFFFFF"
labels = get_tips(nodes),
save = "~/test.png",
scaling = seq_counts * 3)
plot_value_tree(nodes, pcr_proportions, background="#FFFFFF",
labels = get_tips(nodes),
save = "~/test.png",
scaling = seq_counts * 3)
source("http://bioconductor.org/biocLite.R")
biocLite("Biostrings")
install.packages(proxy)
install.packages("proxy")
library(metacoder)
debugonce(get_taxon_sample)
#===================================================================================================
#' Download representative sequences for a taxon
#'
#' Downloads a sample of sequences meant to evenly capture the diversity of a given taxon.
#'
#' @param taxon A character vector of length 1. The taxon to download a sample of sequences for.
#' @param target_level A character vector of length 1. The level finest taxonomic level at which
#'   to sample. The finest level at which replication occurs. Must be a finer level than
#'   \code{taxon}.
#' @param max_counts A named numeric vector. The maximum number of sequences to download for each
#'   taxonomic level. The names correspond to taxonomic levels. See
#'   \code{\link{get_taxonomy_levels}} or \code{\link[taxize]{rank_ref}} for available taxonomic
#'   levels.
get_taxon_sample <- function(name = NULL, id = NULL, target_level, max_counts = NULL,
interpolate_max = TRUE, min_counts = NULL, interpolate_min = TRUE,
verbose = TRUE, ...) {
default_target_max <- 20
default_target_min <- 5
taxonomy_levels <- get_taxonomy_levels()
# Argument validation ----------------------------------------------------------------------------
if (sum(c(is.null(name), is.null(id))) != 1) {
stop("Either name or id must be speficied, but not both")
}
# Argument parsing -------------------------------------------------------------------------------
if (!is.null(name)) {
result <- get_colid(name, verbose = verbose)
if (is.na(result)) stop(cat("Could not find taxon ", name))
id <- result
}
taxon_classification <- classification(id, db = 'col')[[1]]
taxon_level <- factor(taxon_classification[nrow(taxon_classification), "rank"],
levels = levels(taxonomy_levels),
ordered = TRUE)
target_level <- factor(target_level,
levels = levels(taxonomy_levels),
ordered = TRUE)
# Generate taxonomic level sequences count limits ------------------------------------------------
get_level_limit <- function(user_limits, default_value, default_level, interpolate) {
# Provide defaults if NULL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (is.null(user_limits)) {
user_limits <- c(default_value)
names(user_limits) <- default_level
} else if (length(user_limits) == 1 && is.null(names(user_limits))) {
names(user_limits) <- default_level
}
# Order by taxonomic level - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
limit_levels <- factor(names(user_limits),
levels = levels(taxonomy_levels),
ordered = TRUE)
user_limits <- user_limits[order(limit_levels)]
# place input values in vector with all levels - - - - - - - - - - - - - - - - - - - - - - - - -
all_user_limits <- rep(as.integer(NA), length(taxonomy_levels))
names(all_user_limits) <- levels(taxonomy_levels)
all_user_limits[names(user_limits)] <- user_limits
# Interpolate limits for undefined intermediate levels - - - - - - - - - - - - - - - - - - - - -
if (interpolate && length(user_limits) >= 2) {
set_default_counts <- function(range) {
between <- which(taxonomy_levels >= range[1] & taxonomy_levels <= range[2])
all_user_limits[between] <<- as.integer(seq(user_limits[range[1]],
user_limits[range[2]],
along.with = between))
return(NULL)
}
zoo::rollapply(names(user_limits), width = 2, set_default_counts)
}
return(all_user_limits)
}
level_max_count <- get_level_limit(max_counts, default_target_max, target_level, interpolate_max)
level_min_count <- get_level_limit(min_counts, default_target_min, target_level, interpolate_min)
# Recursivly sample taxon ------------------------------------------------------------------------
recursive_sample <- function(id, level) {
if (level >= target_level) {
# Search for sequences - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
taxon_name <- col_search(id = id)[[1]]$name
} else {
# Get children of taxon  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
children <- col_children(id)
}
}
}
debugonce(get_taxon_sample)
get_taxon_sample(id = 4762, target_level = "Genus")
taxonomy_levels
if (!is.null(name)) {
result <- get_uid(name, verbose = verbose)
if (is.na(result)) stop(cat("Could not find taxon ", name))
id <- result
}
name
id
library(taxize)
?classification
?get
?get_id
?classifications
?classification
get_taxon_sample <- function(name = NULL, id = NULL, target_level, max_counts = NULL,
interpolate_max = TRUE, min_counts = NULL, interpolate_min = TRUE,
verbose = TRUE, ...) {
default_target_max <- 20
default_target_min <- 5
taxonomy_levels <- get_taxonomy_levels()
# Argument validation ----------------------------------------------------------------------------
if (sum(c(is.null(name), is.null(id))) != 1) {
stop("Either name or id must be speficied, but not both")
}
# Argument parsing -------------------------------------------------------------------------------
if (!is.null(name)) {
result <- get_uid(name, verbose = verbose)
if (is.na(result)) stop(cat("Could not find taxon ", name))
id <- result
}  else {
id <- as.character(id)
attr(id, "class") <- "uid"
}
taxon_classification <- classification(id, db = 'ncbi')[[1]]
taxon_level <- factor(taxon_classification[nrow(taxon_classification), "rank"],
levels = levels(taxonomy_levels),
ordered = TRUE)
target_level <- factor(target_level,
levels = levels(taxonomy_levels),
ordered = TRUE)
# Generate taxonomic level sequences count limits ------------------------------------------------
get_level_limit <- function(user_limits, default_value, default_level, interpolate) {
# Provide defaults if NULL - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if (is.null(user_limits)) {
user_limits <- c(default_value)
names(user_limits) <- default_level
} else if (length(user_limits) == 1 && is.null(names(user_limits))) {
names(user_limits) <- default_level
}
# Order by taxonomic level - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
limit_levels <- factor(names(user_limits),
levels = levels(taxonomy_levels),
ordered = TRUE)
user_limits <- user_limits[order(limit_levels)]
# place input values in vector with all levels - - - - - - - - - - - - - - - - - - - - - - - - -
all_user_limits <- rep(as.integer(NA), length(taxonomy_levels))
names(all_user_limits) <- levels(taxonomy_levels)
all_user_limits[names(user_limits)] <- user_limits
# Interpolate limits for undefined intermediate levels - - - - - - - - - - - - - - - - - - - - -
if (interpolate && length(user_limits) >= 2) {
set_default_counts <- function(range) {
between <- which(taxonomy_levels >= range[1] & taxonomy_levels <= range[2])
all_user_limits[between] <<- as.integer(seq(user_limits[range[1]],
user_limits[range[2]],
along.with = between))
return(NULL)
}
zoo::rollapply(names(user_limits), width = 2, set_default_counts)
}
return(all_user_limits)
}
level_max_count <- get_level_limit(max_counts, default_target_max, target_level, interpolate_max)
level_min_count <- get_level_limit(min_counts, default_target_min, target_level, interpolate_min)
# Recursivly sample taxon ------------------------------------------------------------------------
recursive_sample <- function(id, level) {
if (level >= target_level) {
# Search for sequences - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
taxon_name <- col_search(id = id)[[1]]$name
} else {
# Get children of taxon  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
children <- col_children(id)
}
}
}
debugonce(get_taxon_sample)
get_taxon_sample(id = "oomycetes", target_level = "Genus")
id
debugonce(get_taxon_sample)
get_taxon_sample(name = "oomycetes", target_level = "Genus")
id
name
result
str(result)
id
taxon_classification
taxon_level
target_level
taxon_level
level_min_count
level_max_count
ncbi_search
?ncbi_search
?ncbi_getbyid
?get_uid
?ncbi_search
ncbi_search("4762")
ncbi_search(4762)
id
id <- "4762"
attr(id, "class") = "uid"
classification(id)
?col_search
x = ncbi_search("Oomycetes")
x
classification(id)
?ncbi_search
x
str(x)
?sample
col_children("oomycota")
classification.uid <- function(id, ...) {
fun <- function(x){
# return NA if NA is supplied
if(is.na(x)){
out <- NA
} else {
baseurl <- "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy"
ID <- paste("ID=", x, sep = "")
searchurl <- paste(baseurl, ID, sep = "&")
tt <- getURL(searchurl)
ttp <- xmlTreeParse(tt, useInternalNodes = TRUE)
out <- data.frame(name = xpathSApply(ttp, "//TaxaSet/Taxon/LineageEx/Taxon/ScientificName", xmlValue),
rank = xpathSApply(ttp, "//TaxaSet/Taxon/LineageEx/Taxon/Rank", xmlValue),
stringsAsFactors = FALSE)
out <- rbind(out, c(xpathSApply(ttp, "//TaxaSet/Taxon/ScientificName", xmlValue),
xpathSApply(ttp, "//TaxaSet/Taxon/Rank", xmlValue),
xpathSApply(ttp, "//TaxaSet/Taxon/TaxId", xmlValue)))
return(out)
}
# NCBI limits requests to three per second
Sys.sleep(0.33)
return(out)
}
out <- lapply(id, fun)
names(out) <- id
class(out) <- 'classification'
attr(out, 'db') <- 'ncbi'
return(out)
}
debugonce(classification.uid)
classification.uid(4738)
debugonce(classification.uid)
classification.uid(4738)
debugonce(fun)
ID
searchurl
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&term=oomycete[Next Level]"
tt <- getURL(searchurl)
library(RCurl)
tt <- getURL(searchurl)
tt
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&term=oomycete"
tt <- getURL(searchurl)
tt
searchurl <- paste(baseurl, ID, sep = "&")
tt <- getURL(searchurl)
tt
searchurl
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&term=oomycete[Next+Level]"
tt <- getURL(searchurl)
tt
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&ID=4738[Next+Level]"
tt <- getURL(searchurl)
tt
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&ID=4762[Next+Level]"
tt <- getURL(searchurl)
tt
strsplit(tt, split = "\n")
searchurl <-  "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=taxonomy&term=Oomycetes[Next+Level]"
?xpathSApply
?xmlTreeParse
?xmlValue
